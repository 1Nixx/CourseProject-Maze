unit MazeSave;

interface
uses
  MazeMain;

const
  ProgDir = 'Maze\';
  TypeFileAddr = 'MazeHistory.ini';
  TextFileDir = 'Mazes';
  TextFileAddr = TextFileDir + '\';

Procedure SaveMazeToFile(Const MazeToSave: TMaze; const MazeStat: TMazeStat);
Procedure SaveMazeToTypeFile(Const MazeStat: TMazeStat; const FileAddr: String);
Function GetRecordsAmount(const FileAddr: String): Integer;
Function ReadFromTypeFile(const RecordToRead: Integer; const FileAddr: string): TMazeStat;
Procedure ClearTypeFile(const FileAddr: String);
Procedure DeleteRecord(const RecordToDel: Integer; const FileAddr: String);

Implementation
Uses
  SysUtils, shlobj, Windows;

function GetAppDataPath: String;
const
  SHGFP_TYPE_CURRENT = 0;
var
  path: array [0..MAX_PATH] of char;
  UserPath: String;
begin
 SHGetFolderPath(0, CSIDL_APPDATA, 0, SHGFP_TYPE_CURRENT, @path);
 userPath:= Path;
 UserPath:= UserPath + '\' + ProgDir;
 if not DirectoryExists(UserPath) then
   CreateDir(UserPath);
end;

//Write maze to text file
Procedure WriteMaze(Const MazeToWrite: TMaze; Const StartPos, EndPos: TPos; const FileHand: TextFile);
Var
  PrintMazeY, PrintMazeX: Integer;
begin
  // Displaying the maze visualization
  For PrintMazeX := 0 to 2 * Length(MazeToWrite[0]) + 1 do
    Write(FileHand, '#');
  Writeln(FileHand);
  For PrintMazeY := 0 to Length(MazeToWrite) - 1 do
  Begin
    Write(FileHand, '#');
    For PrintMazeX := 0 to Length(MazeToWrite[0]) - 1 do
    Begin

      { Determine what type the cell belongs to
        Display the corresponding symbol }
      If (PrintMazeY = StartPos.PosY) and (PrintMazeX = StartPos.PosX) then
        Write(FileHand, #149, ' ')
      else If MazeToWrite[PrintMazeY, PrintMazeX] = Wall then
        Write(FileHand, '##')
      else If (PrintMazeY = EndPos.PosY) and (PrintMazeX = EndPos.PosX) then
        Write(FileHand, ' o')
      else
        Write(FileHand, '  ');
    End;

    Writeln(FileHand, '#');
  End;
  For PrintMazeX := 0 to 2 * Length(MazeToWrite[0]) + 1 do
    Write(FileHand, '#');
end;

//Write maze to text file
Procedure SaveMazeToFile(Const MazeToSave: TMaze; const MazeStat: TMazeStat);
var
  F: TextFile;
  NewFileName, NewFileName2: string;
begin

  CreateDir(TextFileDir);

  //Generate file name
  DateTimeToString(NewFileName, 'ddmmyy/hhnnss', Now);
  NewFileName2 := MazeStat.FileName + '_'+ NewFileName;
  //Save
  AssignFile(F, TextFileAddr + NewFileName2 + '.txt');
  Rewrite(F);

  WriteMaze(MazeToSave, MazeStat.StartPoint, MazeStat.EndPoint, F);

  CloseFile(F);
end;

//Save to Typed File
Procedure SaveMazeToTypeFile(Const MazeStat: TMazeStat; const FileAddr: String);
var
  F: File of TMazeStat;
  FileAddr: String;
begin
  FileAddr := GetAppDataPath + TypeFileAddr;
  try
    AssignFile(F, FileAddr);
    Reset(F)
  except
    Rewrite(F);
  end;

  {if FileExists(FileAddr) then
    Reset(F)
  else
    Rewrite(F);  }

  Seek(F, FileSize(F));
  Write(F, MazeStat);

  CloseFile(F);
end;

//Get FileSize
Function GetRecordsAmount(const FileAddr: String): Integer;
var
  F: File of TMazeStat;
begin
  if not FileExists(FileAddr) then
  begin
    Result := 0;
    Exit;
  end;
  AssignFile(F, FileAddr);
  Reset(F);

  Result := FileSize(F);

  CloseFile(F);
end;

//Get Record with number
Function ReadFromTypeFile(const RecordToRead: Integer; const FileAddr: string): TMazeStat;
var
  F: File of TMazeStat;
begin
  if not FileExists(FileAddr) then Exit;

  AssignFile(F, FileAddr);
  Reset(F);

  Seek(F, RecordToRead-1);
  Read(F, Result);

  CloseFile(F);
end;

//Delete all records in type file
Procedure ClearTypeFile(const FileAddr: String);
var
  F: File of TMazeStat;
begin
  AssignFile(F, FileAddr);
  Rewrite(F);
  CloseFile(F);
end;

//Delete record with number
procedure DeleteRecord(const RecordToDel: Integer; const FileAddr: String);
var
  F: File of TMazeStat;
  I: Integer;
  Buff: TMazeStat;
begin
  if RecordToDel > GetRecordsAmount(FileAddr) then
    Exit;

  AssignFile(F, FileAddr);
  Reset(F);

  Seek(F,RecordToDel-1);

  //Shift all records
  for i := RecordToDel-1 to FileSize(F)-2 do
  begin
    seek(f,i+1);
    read(f,Buff);
    seek(f,i);
    write(f,Buff);
  end;
  Seek(F, FileSize(F)-1);
  Truncate(F);
  CloseFile(F);
end;

end.
