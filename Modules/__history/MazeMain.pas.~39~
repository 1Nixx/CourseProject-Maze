unit MazeMain;

interface
type
  TMaze = array of array of (Wall, Pass, Visited);
  TPos = record
    PosX, PosY: Integer;
  end;
  TMazeSize = (Small, Medium, Large);
  TMazeGenAlg = (HuntAKill, BackTrack, Prim);
  TMazeSolveAlg = (BFS, DFS, LeftHand, RightHand);
  TRoute = array of TPos;

  TMazeStat = packed record
    FileName: String[50];
    DateTime: TDateTime;
    MazeSeed: Integer;
    MazeSize: TMazeSize;
    GenStartPos: TPos;
    StartPoint, EndPoint: TPos;
    MazeGenAlg: TMazeGenAlg;
    MazeSolveAlg: TMazeSolveAlg;
    VisitedCells: packed record
      Route: Integer;
      FullRoute: Integer;
    end;
    TotalTime : packed record
      SolvingTime: Integer;
      GenTime: Integer;
    end;
  end;

const
  MazeSize: array[TMazeSize, 0..1] of Integer = ((15, 15), (30, 30), (500, 500));

  Procedure CleanMaze(var MazeToClean: TMaze);
  function GetExitCell(const MazeToFind: TMaze): TPos;
  function GetStartCell(const MazeToFind: TMaze): TPos;

implementation

  Procedure CleanMaze(var MazeToClean: TMaze);
  var
    I: Integer;
    J: Integer;
  begin
    for I := Low(MazeToClean) to High(MazeToClean) do
      for J := Low(MazeToclean[I]) to High(MazeToClean[I]) do
        MazeToClean[I,J] := Wall;
  end;

  function GetExitCell(const MazeToFind: TMaze): TPos;
  var
    I: Integer;
  begin
    for I := High(MazeToFind[0]) downto Low(MazeToFind[0]) do
      if MazeToFind[High(MazeToFind), I] = Pass then
      begin
        Result.PosX := I;
        Result.PosY := High(MazeToFind);
        Exit;
      end;
  end;

  function GetStartCell(const MazeToFind: TMaze): TPos;
  var
    I: Integer;
  begin
    for I := Low(MazeToFind[0]) to High(MazeToFind[0]) do
      if MazeToFind[Low(MazeToFind), I] = Pass then
      begin
        Result.PosX := I;
        Result.PosY := Low(MazeToFind);
        Exit;
      end;
  end;

end.
